Authors         : Avery Lindley,  Noah Schroeder, Grant Siebring, Blake Eggleston
Last modified   : 12/09/2016


NOTICE:
  As of Friday Dec. 9th this compiler will only compile flair programs
    with arithmetic expressions in the main program body.


Compile & Run:
  A.  Everything
    1.  make

  B.  Scanner
    1.  make scanner
    2.  ./flairs <filename>

  C.  Parser
    1.  make parser
    2.  ./flairp <filename>

  D.  SemanticAnalyzer
    1.  make parser
    2.  ./flairv <filename>
    3.  Run as ./flairp -t <filename>
      a. This saves AST to a file in the root directory called <filename>.dot
      b. Open with GraphViz to see the new tree graph

  E.  Code Generator
    1.  make
    2.  ./flairc <filename>
    3.  Run as ./flairc -t <filename>
      a. This saves AST to a file in the root directory called <filename>.dot
      b. Open with GraphViz to see the new tree graph

  F  Test script
    1.  make run


Optimizations:
  Our compiler supports files of any extension, including .kln.
  Our compiler can create AST diagrams using .DOT files and Graphviz.
  Our scanner supports detailed debug information, making syntax error correcting easier.
  Our parser supports detailed debug information, making semantic error correcting easier.


Implementation backlog:
  =( Code Generator ONLY generates TM for arithmetic operations inside the main program body. E.g. <return (6+(6+(2*5))-((1*999)-12)+((12-3))+9)>
  =( Three address code can be generated for any program, but cannot be utilized in the TM translation.
  =( Type checking is not implemented.
  =( Runtime stack is not functional in its current state.
  =( Print is not a separate TM function, but rather just an OUT statement.


Known Issues:
  The TM code being generated inside the main body is not formatted correctly and is no neat looking.
  As of Friday Dec. 9 an unknown bug has made our TM files unable to be run.
    Will resubmit when bug has been found and corrected.
  Needs better source code documentation.
  Documents that are generated by this code are output to the root directory and not the source folder.
  We regenerate JavaDoc on every compilation. This is a design decision and is intentional.
  SymbolTable does NOT record the name(list) of the function(s) in which it is referenced.



Directory Structure :
  bin/              : stores the binary files
  doc/              : stores the javadoc
  src/              : stores the .java files in a structure that is self descriptive
  test_programs/    : stores the .flr files used to test the project parts
  flairp            : script to run the parser
  flairs            : script to run the scanner
  flairv            : script used to output and test the SymbolTable
  flairc            : script used to create a .tm file with same name as original
  flairTest         : script that runs all of our test programs
  Makefile          : Contains the make commands for ease-of-use





High level Scanner design:
  Our scanner uses the same logic as a finite state automata.
  As the scanner takes in tokens, it switches states for when
  it is looking for a token, when it is taking an integer,
  and when it is taking in a string.
  It switches through these states to treat each token or character
  appropriately, and returns the type of each individual token.

High level Parser design:
  The parser takes the grammar rules, based on the grammar logic table for flair.
  This table is represented in a parseTable, and within this we create rule objects,
  add those objects to the table in specific locations, and the parse algorithm then
  uses that table to confirm there is no bad flair grammar in the input file.

  Upon completing the parsing of a file, the object returns true or
  false representing if the file is a proper flair program. The AST
  that is generated is then stored in the 'TableDrivenParser' object.

High level AST Design:
  Our AST is an object type ProgramNode.
  This SemanticNode object has children that are also different types
    SemanticNodes. Upon completing the SymbolTable and TypeChecker
    these nodes will contain attributes referencing their datatypes and
    other necessary information. Upon completing the 'ParseProgram()'
    method in TableDrivenParser we store the final tree which can be
    accessed using 'getAST()'.
